import { createHash } from "crypto";
import {
  createReadStream,
  createWriteStream,
  statSync,
  existsSync,
  writeFileSync,
  readFileSync,
  unlinkSync,
} from "fs";
import { readdir } from "fs/promises";
import { tmpdir } from "os";
import { join, resolve, relative } from "path";
// import { formatBytes, uploadToPresignedUrl } from "./util"; // Disabled with sync
// import archiver from "archiver"; // Disabled: archiver uses fs and breaks in browsers
import axios from "axios";
import beamClient from "./index";

// Global workspace object id to signal to any other threads that the workspace has already been synced
let _workspaceObjectId = "";
let _syncLock = false;

export function setWorkspaceObjectId(objectId: string): void {
  _workspaceObjectId = objectId;
}

export function getWorkspaceObjectId(): string {
  return _workspaceObjectId || "";
}

function ignoreFileName(): string {
  return ".beamignore";
}

function ignoreFileContents(): string {
  return `# Generated by Beam SDK
.beamignore
pyproject.toml
.git
.idea
.python-version
.vscode
.venv
venv
__pycache__
.DS_Store
.config
drive/MyDrive
.coverage
.pytest_cache
.ipynb
.ruff_cache
.dockerignore
.ipynb_checkpoints
.env.local
.envrc
**/__pycache__/
**/.pytest_cache/
**/node_modules/
**/.venv/
*.pyc
.next/
.circleci
`;
}

export interface ObjectMetadata {
  name: string;
  size: number;
}

export interface CreateObjectRequest {
  objectMetadata: ObjectMetadata;
  hash: string;
  size: number;
  overwrite: boolean;
}

export interface CreateObjectResponse {
  ok: boolean;
  objectId: string;
  presignedUrl: string;
}

export interface HeadObjectRequest {
  hash: string;
}

export interface HeadObjectResponse {
  exists: boolean;
  ok: boolean;
  objectId: string;
  objectMetadata: any | null;
  errorMsg: string;
  useWorkspaceStorage: boolean;
}

export interface PutObjectRequest {
  chunk: Buffer;
  metadata: ObjectMetadata;
  hash: string;
  isFinal: boolean;
}

export interface FileSyncResult {
  success: boolean;
  objectId: string;
}

export class FileSyncer {
  private rootDir: string;
  private isWorkspaceDir: boolean;
  private ignorePatterns: string[] = [];
  private includePatterns: string[] = [];

  constructor(rootDir: string = ".") {
    this.rootDir = resolve(rootDir);
    this.isWorkspaceDir = rootDir === ".";
  }

  private get ignoreFilePath(): string {
    return join(this.rootDir, ignoreFileName());
  }

  private initIgnoreFile(): void {
    if (existsSync(this.ignoreFilePath)) {
      return;
    }

    console.log(`Writing ${ignoreFileName()} file`);
    writeFileSync(this.ignoreFilePath, ignoreFileContents());
  }

  private readIgnoreFile(): string[] {
    console.log(`Reading ${ignoreFileName()} file`);

    const patterns: string[] = [];

    if (existsSync(this.ignoreFilePath)) {
      const content = readFileSync(this.ignoreFilePath, "utf-8");
      return content
        .split("\n")
        .map((line) => line.trim())
        .filter((line) => line && !line.startsWith("#"));
    }

    return patterns;
  }

  private shouldIgnore(filePath: string): boolean {
    const relativePath = relative(this.rootDir, filePath);

    // Simple pattern matching - could be enhanced with proper glob matching
    return this.ignorePatterns.some((pattern) => {
      if (pattern === "*") return true;
      if (pattern.startsWith("**/")) {
        return relativePath.includes(pattern.slice(3));
      }
      if (pattern.endsWith("/**")) {
        return relativePath.startsWith(pattern.slice(0, -3));
      }
      if (pattern.includes("*")) {
        const regex = new RegExp(pattern.replace(/\*/g, ".*"));
        return regex.test(relativePath);
      }
      return relativePath === pattern || relativePath.startsWith(pattern + "/");
    });
  }

  private shouldInclude(filePath: string): boolean {
    if (this.includePatterns.length === 0) {
      return true;
    }

    const relativePath = relative(this.rootDir, filePath);

    return this.includePatterns.some((pattern) => {
      if (pattern.includes("*")) {
        const regex = new RegExp(pattern.replace(/\*/g, ".*"));
        return regex.test(relativePath);
      }
      return relativePath === pattern || relativePath.startsWith(pattern + "/");
    });
  }

  private async *collectFiles(): AsyncGenerator<string> {
    if (this.ignorePatterns.includes("*")) {
      return;
    }

    console.log(`Collecting files from ${this.rootDir}`);

    const walk = async (dir: string): Promise<string[]> => {
      const files: string[] = [];
      try {
        const entries = await readdir(dir, { withFileTypes: true });

        for (const entry of entries) {
          const fullPath = join(dir, entry.name);

          if (entry.isDirectory()) {
            if (!this.shouldIgnore(fullPath)) {
              const subFiles = await walk(fullPath);
              files.push(...subFiles);
            }
          } else if (entry.isFile()) {
            if (!this.shouldIgnore(fullPath) && this.shouldInclude(fullPath)) {
              files.push(fullPath);
            }
          }
        }
      } catch (error) {
        console.warn(`Failed to read directory ${dir}: ${error}`);
      }
      return files;
    };

    const allFiles = await walk(this.rootDir);
    for (const file of allFiles) {
      yield file;
    }
  }

  private static calculateSha256(filePath: string): Promise<string> {
    return new Promise((resolve, reject) => {
      const hash = createHash("sha256");
      const stream = createReadStream(filePath);

      stream.on("error", reject);
      stream.on("data", (chunk) => hash.update(chunk));
      stream.on("end", () => resolve(hash.digest("hex")));
    });
  }

  private async createZipFile(): Promise<{
    filePath: string;
    size: number;
    hash: string;
  }> {
    // Disabled: archiver uses fs and breaks in browsers. For now, throw to indicate unsupported.
    throw new Error(
      "createZipFile is disabled in browser-safe builds (archiver removed)"
    );
  }

  private async headObject(hash: string): Promise<HeadObjectResponse> {
    const response = await beamClient.request({
      method: "GET",
      url: `/api/v1/gateway/objects/${hash}`,
    });

    return response.data;
  }

  private async createObject(
    request: CreateObjectRequest
  ): Promise<CreateObjectResponse> {
    const response = await beamClient.request({
      method: "POST",
      url: `/api/v1/gateway/objects`,
      data: request,
    });

    return response.data;
  }

  public async sync(
    ignorePatterns: string[] = [],
    includePatterns: string[] = [],
    cacheObjectId: boolean = true
  ): Promise<FileSyncResult> {
    // Simple lock mechanism
    if (_syncLock) {
      console.log("Sync already in progress");
      return { success: false, objectId: "" };
    }

    try {
      _syncLock = true;

      if (this.isWorkspaceDir && getWorkspaceObjectId() !== "") {
        console.log("Files already synced");
        return { success: true, objectId: getWorkspaceObjectId() };
      }

      return await this._sync(ignorePatterns, includePatterns, cacheObjectId);
    } finally {
      _syncLock = false;
    }
  }

  private async _sync(
    ignorePatterns: string[] = [],
    includePatterns: string[] = [],
    cacheObjectId: boolean = true
  ): Promise<FileSyncResult> {
    console.log("Syncing files");

    // this.initIgnoreFile(); // Disabled: uses Node fs

    if (!ignorePatterns || ignorePatterns.length === 0) {
      // this.ignorePatterns = this.readIgnoreFile(); // Disabled: uses Node fs
      this.ignorePatterns = [];
    } else {
      this.ignorePatterns = ignorePatterns;
    }

    if (!includePatterns || includePatterns.length === 0) {
      this.includePatterns = [];
    } else {
      this.includePatterns = includePatterns;
    }

    // const { filePath: tempZipPath, size, hash } = await this.createZipFile();
    // Temporarily disable sync that requires zipping since archiver is removed
    console.error("Sync disabled: archiving removed for browser compatibility");
    return { success: false, objectId: "" };

    // if (!this.ignorePatterns.includes("*")) {
    //   console.log(`Collected object is ${formatBytes(size)}`);
    // }

    // Archiver-dependent sync flow disabled for browser compatibility.
    // try { /* ... */ } finally { /* ... */ }
  }
}
